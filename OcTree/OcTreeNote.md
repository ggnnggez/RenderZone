# OcTree Note

### 问题引入
现有一个巨大的场景，场景内有数量巨大的GameObject，且每个GameObject的Mesh各不相同。需求是付出能够接受的性能，我们需要知道每一帧场景内有哪些GameObject相交。
![问题附图](https://uploads.gamedev.net/monthly_01_2014/ccs-13892-0-48142200-1389658066.png)
##### 1.暴力检测
```c#
foreach(gameObject myObject in ObjList)
{
	foreach(gameObject otherObject in ObjList) 
	{ 
		if(myObject == otherObject) continue; //avoid self collision check 
		if(myObject.CollidesWith(otherObject)) 
		{ 
		//code to handle the collision 
		} 
	} 
}
```
虽然是$O(N^2)$的复杂度，但是在场景中对象较少的时候还是可以用的(检测次数少于100)
###### 1.1
在遇到碰撞检测方面的性能瓶颈时可以考虑下面几种方法去优化:

1. 检查碰撞检测算法内是否包含了大量的`Sqrt()`方法，由于大部分的原生
的开方方法都是使用牛顿迭代法来做，性能消耗较大。特别是计算两个对象距离时，要使用距离的平方而不是平方根来做。
2. 是否能够减少参与计算碰撞检测的对象？
   将那些运动确定的且不会与其他对象发生碰撞的对象不做碰撞检测，比如将对象分为静止对象列表与运动对象列表，只对运动对象列表做碰撞检测。
3. 建立碰撞检测的优先级……
4. **使用空间划分方法**

##### 2.基于空间划分方法的检测
还是上述的那个场景，我们把场景从中间一分为二，根据对象所处的空间，我们可以把对象放入三个列表中，处于左半边的对象放在列表A中，处于右半边的对象放在列表B中，被划分线穿过的对象我们放在列表C中。
![空间划分_fig01](https://uploads.gamedev.net/monthly_01_2014/ccs-13892-0-11639700-1389661386.png)

我们可以确定，ListA中的对象不可能与ListB中的对象相交，故我们只需要对AB列表中的对象各自求交，以及ListC中的对象与A和B中的对象求交。

那么问题来了，如果对象不均匀，比如所有对象全都聚集在空间的左半边，那么这么做空间划分也无济于事。还有对象如果每帧都在移动且趋势无法预测，难道每一帧都要生成一棵树吗？

###### 2.1 要不要进行分割？怎么进行分割？
